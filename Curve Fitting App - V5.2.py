# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'GUI5_Task4.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import sys
import qdarkstyle
from PyQt5.QtWidgets import QDialog, QApplication, QPushButton, QVBoxLayout
from PyQt5.QtWidgets import QFileDialog, QGraphicsScene
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import QApplication, QWidget, QProgressBar, QPushButton, QVBoxLayout
import pandas as pd
from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5.QtWidgets import QApplication, QWidget, QProgressBar, QPushButton, QVBoxLayout
import sys
import time
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
import matplotlib.pyplot as plt
import random
from PyQt5.QtCore import QThread, QObject, pyqtSignal
import threading

from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import numpy,pylab
from numpy import *
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QApplication, QWidget, QAction, QTableWidget,QTableWidgetItem,QVBoxLayout
import sys
from PyQt5.QtCore import QTimer

import logging

# Create and configure logger
logging.basicConfig(filename="loggingFile.log",
                    format='%(asctime)s %(message)s',
                    filemode='w')

# Creating an object
logger = logging.getLogger()

# Setting the threshold of logger to DEBUG
logger.setLevel(20) ## info level
from PyQt5 import QtCore, QtGui, QtWidgets
# from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1250, 682)
        MainWindow.setStyleSheet("")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.splitter = QtWidgets.QSplitter(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.splitter.sizePolicy().hasHeightForWidth())
        self.splitter.setSizePolicy(sizePolicy)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setOpaqueResize(True)
        self.splitter.setChildrenCollapsible(False)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setSpacing(12)
        self.verticalLayout.setObjectName("verticalLayout")

        #############################################
        # self.widget_mainGraph = QtWidgets.QWidget(self.layoutWidget)
        # self.widget_mainGraph.setMinimumSize(QtCore.QSize(800, 600))
        # self.widget_mainGraph.setObjectName("widget_mainGraph")
        self.figure_mainGraph = Figure(figsize=(3, 3), dpi=100)  # making figure with two axes , table and main graph
        self.axes_mainGraph = self.figure_mainGraph.add_subplot(211)
        self.table_axes_mainGraph = self.figure_mainGraph.add_subplot(212)
        self.canvas_mainGraph = FigureCanvas(self.figure_mainGraph)
        self.canvas_mainGraph.figure.set_facecolor("#19232D") #applying the GUI's color on matplotlib to look nice
        # self.navi_toolbar = NavigationToolbar(self.canvas_mainGraph)  # create a navigation toolbar for our plot canvas
        self.axes_mainGraph.axes.tick_params(axis="x", colors="white")
        self.axes_mainGraph.axes.tick_params(axis="y", colors="white")
        # self.canvas_mainGraph.resize(800,600)
        self.table_axes_mainGraph.set_position([0.2, 0.1, 0.6, 0.3])  # left,bottom,width,height
        self.verticalLayout.addWidget(self.canvas_mainGraph)

        ##############################################

        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setSpacing(30)
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSpacing(7)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.label = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.horizontalLayout_5.addWidget(self.label)
        self.spinBox_numberOfChunks = QtWidgets.QSpinBox(self.layoutWidget)
        self.spinBox_numberOfChunks.setMinimumSize(QtCore.QSize(0, 30))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.spinBox_numberOfChunks.setFont(font)
        self.spinBox_numberOfChunks.setValue(1)
        self.spinBox_numberOfChunks.setMinimum(1)
        self.spinBox_numberOfChunks.setMaximum(9)
        self.spinBox_numberOfChunks.setObjectName("spinBox_numberOfChunks")
        self.horizontalLayout_5.addWidget(self.spinBox_numberOfChunks)
        self.horizontalLayout.addLayout(self.horizontalLayout_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setSpacing(7)
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.label_2 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_6.addWidget(self.label_2)
        self.spinBox_polynomialOrder = QtWidgets.QSpinBox(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.spinBox_polynomialOrder.sizePolicy().hasHeightForWidth())
        self.spinBox_polynomialOrder.setSizePolicy(sizePolicy)
        self.spinBox_polynomialOrder.setMinimumSize(QtCore.QSize(0, 30))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.spinBox_polynomialOrder.setFont(font)
        self.spinBox_polynomialOrder.setObjectName("spinBox_polynomialOrder")
        self.horizontalLayout_6.addWidget(self.spinBox_polynomialOrder)
        self.spinBox_polynomialOrder.setMaximum(6)
        self.horizontalLayout.addLayout(self.horizontalLayout_6)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.horizontalLayout.setStretch(0, 1)
        self.horizontalLayout.setStretch(1, 1)
        self.horizontalLayout.setStretch(2, 1)
        self.horizontalLayout.setStretch(3, 1)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem2)
        self.checkBox_extrapolaion = QtWidgets.QCheckBox(self.layoutWidget)
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.checkBox_extrapolaion.setFont(font)
        self.checkBox_extrapolaion.setObjectName("checkBox_extrapolaion")
        self.horizontalLayout_2.addWidget(self.checkBox_extrapolaion)
        self.horizontalSlider_extrapolation = QtWidgets.QSlider(self.layoutWidget)
        self.horizontalSlider_extrapolation.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_extrapolation.setMinimum(1)  # avoiding extrapolation being zero
        self.horizontalSlider_extrapolation.setMaximum(10)
        self.horizontalSlider_extrapolation.setValue(5)  # putting the slider in the middle
        self.horizontalSlider_extrapolation.setObjectName("horizontalSlider_extrapolation")
        self.horizontalLayout_2.addWidget(self.horizontalSlider_extrapolation)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem3)
        self.horizontalLayout_2.setStretch(0, 1)
        self.horizontalLayout_2.setStretch(1, 1)
        self.horizontalLayout_2.setStretch(2, 2)
        self.horizontalLayout_2.setStretch(3, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.layoutWidget1 = QtWidgets.QWidget(self.splitter)
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_9.setSpacing(25)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        spacerItem4 = QtWidgets.QSpacerItem(20, 13, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_9.addItem(spacerItem4)
        self.groupBox_errorMap = QtWidgets.QGroupBox(self.layoutWidget1)
        font = QtGui.QFont()
        font.setBold(True)
        font.setWeight(75)
        self.groupBox_errorMap.setFont(font)
        self.groupBox_errorMap.setTitle("")
        self.groupBox_errorMap.setObjectName("groupBox_errorMap")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.groupBox_errorMap)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setSpacing(15)
        self.verticalLayout_4.setObjectName("verticalLayout_4")

        ######################################################################

        self.figure_errorMap = Figure(figsize=(3, 3), dpi=100)
        self.axes_errorMap = self.figure_errorMap.add_subplot()
        self.canvas_errorMap = FigureCanvas(self.figure_errorMap)
        self.canvas_errorMap.figure.set_facecolor("#19232D")
        self.axes_errorMap.axes.tick_params(axis="x", colors="white")
        self.axes_errorMap.axes.tick_params(axis="y", colors="white")
        self.canvas_errorMap.draw
        self.verticalLayout_4.addWidget(self.canvas_errorMap)
        ######################################################################

        # self.widget_errorMap = QtWidgets.QWidget(self.groupBox_errorMap)
        # self.widget_errorMap.setObjectName("widget_errorMap")
        # self.verticalLayout_4.addWidget(self.widget_errorMap)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_xAxis = QtWidgets.QLabel(self.groupBox_errorMap)
        self.label_xAxis.setObjectName("label_xAxis")
        self.verticalLayout_2.addWidget(self.label_xAxis)
        self.comboBox_xAxis = QtWidgets.QComboBox(self.groupBox_errorMap)
        self.comboBox_xAxis.setObjectName("comboBox_xAxis")
        for counter in range(3):
            self.comboBox_xAxis.addItem("")
        # self.comboBox_xAxis.addItem("")
        # self.comboBox_xAxis.addItem("")
        self.verticalLayout_2.addWidget(self.comboBox_xAxis)
        self.horizontalLayout_3.addLayout(self.verticalLayout_2)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_yAxis = QtWidgets.QLabel(self.groupBox_errorMap)
        self.label_yAxis.setObjectName("label_yAxis")
        self.verticalLayout_3.addWidget(self.label_yAxis)
        self.comboBox_yAxis = QtWidgets.QComboBox(self.groupBox_errorMap)
        self.comboBox_yAxis.setObjectName("comboBox_yAxis")
        for counter in range(3):
            self.comboBox_yAxis.addItem("")
        # self.comboBox_yAxis.addItem("")
        # self.comboBox_yAxis.addItem("")
        self.verticalLayout_3.addWidget(self.comboBox_yAxis)
        self.horizontalLayout_3.addLayout(self.verticalLayout_3)
        self.verticalLayout_4.addLayout(self.horizontalLayout_3)
        self.verticalLayout_4.setStretch(0, 5)
        self.verticalLayout_5.addLayout(self.verticalLayout_4)
        self.verticalLayout_9.addWidget(self.groupBox_errorMap)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setSizeConstraint(QtWidgets.QLayout.SetFixedSize)
        self.verticalLayout_8.setSpacing(5)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.progressBar = QtWidgets.QProgressBar(self.layoutWidget1)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setMinimum(0)
        self.progressBar.setMaximum(100)
        self.progressBar.setObjectName("progressBar")
        self.verticalLayout_8.addWidget(self.progressBar)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setSizeConstraint(QtWidgets.QLayout.SetFixedSize)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem5)
        self.pushButton_generateErrorMap = QtWidgets.QPushButton(self.layoutWidget1)
        font = QtGui.QFont()
        font.setPointSize(8)
        font.setBold(True)
        font.setWeight(75)
        self.pushButton_generateErrorMap.setFont(font)
        self.pushButton_generateErrorMap.setObjectName("pushButton_generateErrorMap")
        self.horizontalLayout_4.addWidget(self.pushButton_generateErrorMap)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem6)
        self.horizontalLayout_4.setStretch(0, 1)
        self.horizontalLayout_4.setStretch(1, 1)
        self.horizontalLayout_4.setStretch(2, 1)
        self.verticalLayout_8.addLayout(self.horizontalLayout_4)
        self.verticalLayout_9.addLayout(self.verticalLayout_8)
        self.verticalLayout_9.setStretch(1, 1)
        self.gridLayout_2.addWidget(self.splitter, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1250, 26))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtWidgets.QAction(MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.menuFile.addAction(self.actionOpen)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        self.comboBox_yAxis.setCurrentIndex(1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        ############################################################################################################3
        self.xDots = []
        self.yDots = []
        self.XsubArrays = []
        self.YsubArrays = []
        self.numberOfChunks = 1
        self.timer = QtCore.QTimer()
        self.errorMapData_Chunks_vs_Order = numpy.zeros((3, 3))  ## error map size
        self.errorMapData_Chunks_vs_Overlapping = numpy.zeros((3, 8))  ## over lap is 10,20,30 % ,,then size is 3*8
        self.errorMapData_Order_vs_Overlapping = numpy.zeros((3, 8))
        self.errorMaps = []  # error maps container

        self.spinBox_numberOfChunks.valueChanged.connect(self.Extrapolation_Fitting_Switch)  # check if we want to extrapolate or fitting
        self.spinBox_polynomialOrder.valueChanged.connect(self.Extrapolation_Fitting_Switch)
        self.actionOpen.triggered.connect(self.open)
        self.pushButton_generateErrorMap.clicked.connect(self.threadFunction)
        self.timer.timeout.connect(self.Increase_Step)
        self.checkBox_extrapolaion.toggled.connect(self.Extrapolation_Fitting_Switch)
        self.horizontalSlider_extrapolation.sliderReleased.connect(self.Extrapolation)
        # self.comboBox_xAxis.currentIndexChanged.connect(self.drawErrorMap)
        # self.comboBox_yAxis.currentIndexChanged.connect(self.drawErrorMap)
        self.table_axes_mainGraph.set_axis_off()  # drawing the table without axes


        self.horizontalSlider_extrapolation.hide()  # hide the slider as long as extrapolation is checked false
        self.progressBar.hide()  # hide progress bar by default
        initialBar = [[0, 0], [0, 100]]  ##color bar
        im = self.axes_errorMap.imshow(initialBar)
        self.colorbar = self.canvas_errorMap.figure.colorbar(im)
        # self.colorbar.set_ticks([]) if you want to delete ticks
        self.colorbar.ax.tick_params(colors='white')
        self.axes_errorMap.clear()
        self.GenerateMap_cancel_Flag=True

        ########################################################################################################


    def cancel(self):
        font = QtGui.QFont()
        font.setPointSize(8)
        font.setBold(True)
        font.setWeight(75)
        self.pushButton_generateErrorMap.setFont(font)
        self.pushButton_generateErrorMap.setText("Generate Error Map")  # toggleing the button 
        self.GenerateMap_cancel_Flag = True
        self.timer.stop()  ## progress bar off
        self.progressBar.setValue(0)  ## progress bar off
        self.axes_errorMap.clear()
        self.canvas_errorMap.draw()  # apply changes

    def threadFunction(self):

        if (self.GenerateMap_cancel_Flag == True):  # if the button state was clicked as  (Generate error map)
            self.progressBar.show()
            self.timer.start(10)  # progress bar start
            # self.t1 = threading.Thread(target=self.CalculateErrorMap)  # calculate error map in sub thread
            self.t1 = threading.Thread(target=self.CalculateErrorMap)  # calculate error map in sub thread


            # t1.start()  # thread start

            font2 = QtGui.QFont()  # setting the button to be (cancel)
            font2.setPointSize(9)  # setting the button to be (cancel)
            font2.setBold(True)  # setting the button to be (cancel)
            font2.setWeight(65)  # setting the button to be (cancel)
            self.pushButton_generateErrorMap.setFont(font2)  # setting the button to be (cancel)
            self.pushButton_generateErrorMap.setText("Cancel")  # setting the button to be (cancel)
            self.GenerateMap_cancel_Flag=False



        else:  # if the button was clicked as  cancel
            self.cancel()

    def Increase_Step(self):  ##  progress bar
        self.progressBar.setValue(self.progressBar.value() + 1)  ## progressing
        if (self.progressBar.value() == 100):  ## progress bar ended
            self.progressBar.hide()
            self.timer.stop()
            self.progressBar.setValue(0)
            font = QtGui.QFont()
            font.setPointSize(8)
            font.setBold(True)
            font.setWeight(75)
            self.pushButton_generateErrorMap.setFont(font)
            self.pushButton_generateErrorMap.setText("Generate Error Map")
            self.GenerateMap_cancel_Flag = True
            self.t1.start()


    def two_biggest(self,a, b, c): ## a functoin that return the max 2 number among 3 ,, it's used inside the calculation insinde of the error map
        if a >= b >= c:

            return a, b
        elif b >= c >= a:

            return b, c
        else:

            return c, a
    def CalculateErrorMap(self):

        self.axes_errorMap.clear()
        errorMapIndex = str(self.comboBox_xAxis.currentIndex()) + str( self.comboBox_yAxis.currentIndex())  ##get error map index then plot it
        if (errorMapIndex == "00" or errorMapIndex == "11" or errorMapIndex == "22"):  ## the user chose similar axes
            logger.info("errorMapIndex %s", int(errorMapIndex))

            return
        parametersContainer = [[1], [1], [0]]  ## chunks , order , overlap default values(assuming that they will be consant parameter)

        parametersContainer[self.comboBox_xAxis.currentIndex()] = [1, 2, 3,4] ## update (chunk or order or overlap)list according to the axis needed from the combobox
        parametersContainer[self.comboBox_yAxis.currentIndex()] = [1, 2, 3,4] ## update (chunk or order or overlap)list according to the axis needed from the combobox

        chunks = parametersContainer[0] ## assigning values

        orders = parametersContainer[1] ## assigning values

        overlaps=numpy.array(parametersContainer[2])/10 ## assigning values ## we divide by 10 because overlap is .1 , .2 , .3 .....


        height,width=self.two_biggest(len(chunks),len(overlaps),len(orders)) ## get the biggest 2 numbers from 3 numbers

        errorMapData = numpy.zeros((height,width))

        for chunk in chunks: ##looping through number of chunks
            XsubArrays = numpy.array_split(self.xDots, chunk)
            YsubArrays = numpy.array_split(self.yDots, chunk)
            for overlap in overlaps : #looping through overlapp
                XsubArrays[chunk-1] = numpy.concatenate(((XsubArrays[chunk - 2][int((1 - overlap) * len( XsubArrays[chunk - 2])):]), XsubArrays[ chunk-1]))  ## getting the overlap array then concatenate it to the current array
                YsubArrays[chunk-1] = numpy.concatenate((YsubArrays[chunk - 2][ int((1 - overlap) * len(  YsubArrays[chunk - 2])):], YsubArrays[ chunk-1]))  ## getting the overlap array then concatenate it to the current array

                for order in orders: ## looping through orders
                    coefficient_Of_Determination = 0 ## reset for the error after every loop
                    for chunkIndex in range(len(XsubArrays)): ## this is not code repetition, it's just looping through each chunk to calculate its error, compeletly different from any other for loop in the code

                        XsubArrays[chunkIndex] = numpy.concatenate(((XsubArrays[chunkIndex - 1][
                                                                     int((1 - overlap) * len(
                                                                         XsubArrays[chunkIndex - 1])):]),
                                                                    XsubArrays[chunkIndex]))

                        YsubArrays[chunkIndex] = numpy.concatenate((YsubArrays[chunkIndex - 1][
                                                                    int((1 - overlap) * len(
                                                                        YsubArrays[chunkIndex - 1])):],
                                                                    YsubArrays[chunkIndex]))

                        residuals = numpy.sum((numpy.polyval(
                                    numpy.polyfit(XsubArrays[chunkIndex], YsubArrays[chunkIndex], order),
                                    XsubArrays[chunkIndex]) - YsubArrays[chunkIndex]) ** 2)

                        standard = numpy.std(YsubArrays[chunkIndex])  ##calculate standard deviation
                        deviation = (standard ** 2) * len(YsubArrays[chunkIndex])  ## calculate deviation
                        coefficient_Of_Determination += (  deviation - residuals) / deviation  # The coefficient of determination is r**2


                    error = (len(XsubArrays) - coefficient_Of_Determination) / len(XsubArrays)##error average
                    errorMapData[chunk - 1, order - 1] = error * 100  ## error percentage



        self.errorMaps = {                "02": errorMapData,  ##index of chunk axis is 0 ,, index of order axis is 1 ,, index of overlapping axis 2
                        "01": errorMapData,  ## Here, we map every map to its index
                        "12": errorMapData,
                        "21": errorMapData.transpose(), "10": errorMapData.transpose(), ## assigning indices
                        "20": errorMapData.transpose()}
        self.axes_errorMap.imshow(self.errorMaps[errorMapIndex])
        self.axes_errorMap.tick_params(axis='x', colors='white')  ## set ticks' color to white
        self.axes_errorMap.set_xlabel(self.comboBox_xAxis.currentText(), fontsize=10)  ## set ticks' color to white
        self.axes_errorMap.xaxis.label.set_color('white')  ## set ticks' color to white

        self.axes_errorMap.tick_params(axis='y', colors='white')  ## set ticks' color to white
        self.axes_errorMap.set_ylabel(self.comboBox_yAxis.currentText(),
                                      fontsize=10)  # set labels for the error map
        self.axes_errorMap.yaxis.label.set_color('white')  ## set label color to white

        self.axes_errorMap.set_xticks([])  # remove ticks from error map
        self.axes_errorMap.set_yticks([])

        self.canvas_errorMap.draw()






    def open(self):
        self.spinBox_numberOfChunks.setValue(1)  ##reset
        self.spinBox_polynomialOrder.setValue(0)  ##reset
        self.cancel()  ##reset
        self.axes_errorMap.clear()  ##reset
        self.table_axes_mainGraph.clear()  ##reset
        self.table_axes_mainGraph.set_axis_off()  ##reset
        self.axes_mainGraph.clear()  ##reset
        path = QFileDialog.getOpenFileName()[0]  # reading the file
        data = numpy.genfromtxt(path, delimiter=',')

        self.xDots = list(data[:, 0][1:])
        self.yDots = list(data[:, 1][1:])
        df = pd.read_csv(path)

        list_of_column_names = list(df.columns)  # creating a list of column names by

        self.xLabel = list_of_column_names[0]  # getting axes label from the file
        self.yLabel = list_of_column_names[1]  # getting axes label from the file
        self.axes_mainGraph.plot(self.xDots, self.yDots, 'ko', alpha=0.5)
        self.axes_mainGraph.xaxis.label.set_color('white')
        self.axes_mainGraph.yaxis.label.set_color('white')
        self.axes_mainGraph.set_xlabel(self.xLabel)
        self.axes_mainGraph.set_ylabel(self.yLabel)

        self.canvas_mainGraph.draw()

    def Extrapolation(self):

        self.table_axes_mainGraph.clear()  # reset
        self.axes_mainGraph.clear()  # reset
        self.table_axes_mainGraph.set_axis_off()  # reset
        self.axes_mainGraph.plot(self.xDots, self.yDots, 'ko', alpha=0.5)  # reset
        self.axes_mainGraph.xaxis.label.set_color('white')
        self.axes_mainGraph.yaxis.label.set_color('white')
        self.axes_mainGraph.set_xlabel(self.xLabel)  # reset
        self.axes_mainGraph.set_ylabel(self.yLabel)  # reset

        portion = self.horizontalSlider_extrapolation.value() / 10  ##the portion that we will apply curvefitting on
        logger.info("portion= %s", portion)

        xDotsSlice = self.xDots[:int(len(self.xDots) * portion)]  ##new array afrer clipping
        yDotsSlice = self.yDots[:int(len(self.yDots) * portion)]  ##new array afrer clipping
        order = self.spinBox_polynomialOrder.value()
        if (order == 0):
            order = 1  ##exception handling ,, if the user chose order to be 0 , it will be 1 by default
        coefficient = numpy.polyfit(xDotsSlice, yDotsSlice, order)  # getting polynomial coefficients
        xContinuous = numpy.arange((self.xDots[0]), (self.xDots[-1]), .001)  # xContinuous has same range of xdots but with higher resolution
        yContinuous = polyval(coefficient, xContinuous)
        self.axes_mainGraph.plot(xContinuous, yContinuous, linewidth='3')
        yMin, yMax = self.axes_mainGraph.get_ylim()  ## get limits of the axis to draw line
        self.axes_mainGraph.vlines(xDotsSlice[-1], ymin=yMin, ymax=yMax, colors='k',
                                   linestyles='solid', label='extrapolation start')
        self.axes_mainGraph.legend()
        self.canvas_mainGraph.draw()

    def Extrapolation_Fitting_Switch(self):

        logger.info("checkBox_extrapolaion %s", int(self.checkBox_extrapolaion.isChecked()))

        if self.checkBox_extrapolaion.isChecked() == True:
            self.horizontalSlider_extrapolation.show()
            self.Extrapolation()
        else:
            self.horizontalSlider_extrapolation.hide()
            self.updatePlot()

    def updatePlot(self):
        tableData = {'Chunk': [], 'equation': [], 'error%': []}  # table header

        self.table_axes_mainGraph.clear()  # reset
        self.axes_mainGraph.clear()  # reset
        self.table_axes_mainGraph.set_axis_off()  # reset

        self.axes_mainGraph.plot(self.xDots, self.yDots, 'ko', alpha=0.5)  # reset
        self.axes_mainGraph.set_xlabel(self.xLabel)
        self.axes_mainGraph.set_ylabel(self.yLabel)
        self.numberOfChunks = self.spinBox_numberOfChunks.value()
        self.XsubArrays = numpy.array_split(self.xDots, self.numberOfChunks)  # dividing into chunks
        self.YsubArrays = numpy.array_split(self.yDots, self.numberOfChunks)  # dividing into chunks

        for ChunkIndex in range(self.numberOfChunks):
            logger.info("spinBox_numberOfChunks %s", self.spinBox_numberOfChunks.value())

            tableData['Chunk'].append(ChunkIndex + 1)  ## making index column in the table : 1,2,3,4....

            if (ChunkIndex != self.numberOfChunks - 1):  ## don't draw the splitting line of the last chunk
                self.axes_mainGraph.vlines(self.XsubArrays[ChunkIndex][-1], ymin=min(self.yDots),
                                           ymax=max((self.yDots)), colors='k',
                                           linestyles='dashed')
            if (
                    ChunkIndex != 0):  ## inserting last element in the privious array into the current array ,, except the first chunk
                self.XsubArrays[ChunkIndex] = numpy.insert(self.XsubArrays[ChunkIndex], 0,
                                                           self.XsubArrays[ChunkIndex - 1][-1])
                self.YsubArrays[ChunkIndex] = numpy.insert(self.YsubArrays[ChunkIndex], 0,
                                                           self.YsubArrays[ChunkIndex - 1][-1])

            if (
                    self.spinBox_polynomialOrder.value() > 0):  ## curveFitting if the spin has value ,,else don't draw fitting
                logger.info("spinBox_polynomialOrder %s", self.spinBox_polynomialOrder.value())

                order = self.spinBox_polynomialOrder.value()  ## get order from the spinbox
                coefficients = numpy.polyfit(self.XsubArrays[ChunkIndex], self.YsubArrays[ChunkIndex],
                                             # calculate coefficients
                                             order)
                xContinuous = numpy.arange((self.XsubArrays[ChunkIndex][0]),   (self.XsubArrays[ChunkIndex][-1]), .001)  # xContinuous has same range as xdots but with higher resoultion
                yContinuous = polyval(coefficients, xContinuous)  # calculate yContinuous
                self.axes_mainGraph.plot(xContinuous, yContinuous, linewidth='3')

                string = "$"  #######forming the latex equation
                for i in range(len(coefficients)):
                    if (i == (len(coefficients) - 2)):  ## avoding x ^ 0 in the string
                        coeff = round(coefficients[i], 2)
                        string += str(coeff) + "x"
                        string += '+'
                        continue

                    if (i == len(coefficients) - 1):
                        coeff = round(coefficients[i])
                        string += str(coeff)
                    else:
                        coeff = round(coefficients[i], 2)  ##rounding the number to 2 bits
                        string += str(coeff) + "x^" + str(len(coefficients) - i - 1)
                        string += '+'
                string += "$"
                tableData['equation'].append(string)  ## add equation to the table
                residuals = numpy.sum((numpy.polyval(
                    numpy.polyfit(self.XsubArrays[ChunkIndex], self.YsubArrays[ChunkIndex], order),
                    self.XsubArrays[ChunkIndex]) - self.YsubArrays[ChunkIndex]) ** 2)

                standard = numpy.std(self.YsubArrays[ChunkIndex])
                deviation = (standard ** 2) * len(self.YsubArrays[ChunkIndex])
                coefficient_Of_Determination = (
                                                           deviation - residuals) / deviation  # The coefficient of determination is r**2
                coefficient_Of_Determination = round(coefficient_Of_Determination, 3)
                error = (1 - coefficient_Of_Determination) * 100
                error = round(error, 3)
                tableData['error%'].append(error)  ## add the error to the table

        if (self.spinBox_polynomialOrder.value() > 0):  ## plot the table only if the spin box has value
            TableData_frame = pd.DataFrame(tableData)  ## framing the table with pandas library
            table = self.table_axes_mainGraph.table(cellText=TableData_frame.values, colLabels=TableData_frame.columns,
                                                    loc='center')
            table.auto_set_column_width(col=list(range(len(TableData_frame.columns))))  ## orientation
            table.scale(1, 1.5)
            table.auto_set_font_size(True)

        # self.canvas_mainGraph.resize(600, 800)
        self.canvas_mainGraph.draw()  ##apply changes


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600;\">Number of Chunks</span></p></body></html>"))
        self.label_2.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-size:7pt; font-weight:600;\">Polynomial Order</span></p></body></html>"))
        self.checkBox_extrapolaion.setText(_translate("MainWindow", "Extrapolation"))
        self.label_xAxis.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-weight:600;\">X-Axis</span></p></body></html>"))
        self.comboBox_xAxis.setCurrentText(_translate("MainWindow", "Number of Chunks"))
        self.comboBox_xAxis.setItemText(0, _translate("MainWindow", "Number of Chunks"))
        self.comboBox_xAxis.setItemText(1, _translate("MainWindow", "Order of Polynomial"))
        self.comboBox_xAxis.setItemText(2, _translate("MainWindow", "Overlapping"))
        self.label_yAxis.setText(_translate("MainWindow", "<html><head/><body><p align=\"center\"><span style=\" font-weight:600;\">Y-Axis</span></p></body></html>"))
        self.comboBox_yAxis.setItemText(0, _translate("MainWindow", "Number of Chunks"))
        self.comboBox_yAxis.setItemText(1, _translate("MainWindow", "Order of Polynomial"))
        self.comboBox_yAxis.setItemText(2, _translate("MainWindow", "Overlapping"))
        self.pushButton_generateErrorMap.setText(_translate("MainWindow", "Generate Error Map"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    app.setStyleSheet(qdarkstyle.load_stylesheet())
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
